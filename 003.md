## 問題 3

ML エンジニアが、Amazon SageMaker Canvas を使用して ML モデルをトレーニングするためにデータを利用する必要があります。

データは Amazon S3 に保存されており、構造が複雑です。

ML エンジニアは、データの処理時間を最小限に抑えるファイル形式を使用する必要があります。

これらの要件を満たすファイル形式を選択してください。

## 解答

Apache Parquet ファイル

## 解説

Apache Parquet ファイルは、列指向形式でデータの処理時間を最小限に抑えられるため正解です。

具体的には、Apache Parquet ファイルは列指向のストレージ形式であるため、大量のデータを効率的に圧縮および処理できます。

Amazon SageMaker Canvas は、データ分析や機械学習モデルのトレーニングで高いパフォーマンスを提供するため、この形式に最適化されています。

さらに、Amazon S3 に保存されたデータを使用する場合、Parquet 形式は、列単位でのアクセスを可能にするため、複雑な構造を持つデータセットでも必要な部分だけを効率的に読み取ることが可能です。

これにより、データ処理時間を最小限に抑えられます。

---

### データの保存方法の簡単な説明

#### 1. テーブル形式のデータの場合（行形式と列形式）

- **行形式**

  - 各行が 1 つの情報のセットを表します。
  - 例：1 人分の生徒情報（名前、年齢、住所など）が 1 行にまとまっています。
  - 特徴：1 人分の情報をまとめて取り出す場合に便利です。

- **列形式**
  - 同じ種類の情報が、すべてまとめて 1 つの列に入ります。
  - 例：全員の名前は「名前」列、全員の年齢は「年齢」列にそれぞれ保存されます。
  - 特徴：必要な項目だけを素早く取り出せるので、大量のデータの中から特定の情報を探すときにとても効率的です。

---

#### 2. その他のデータの保存方法

テーブル形式以外にも、データを保存する方法はたくさんあります。たとえば：

- **ドキュメント形式**
  - 情報を文章のように保存します。（例：JSON、XML）
- **キー・バリュー形式**
  - 「キー」と呼ばれる名前と、それに対応する「値」をセットで保存します。（例：辞書のように「名前―太郎」）
- **グラフ形式**
  - 点と線を使って、情報同士のつながりを表現します。（例：SNS の友達関係）

---

### まとめ

テーブル形式のデータの場合、

- 「行形式」は 1 人分の情報をひとまとまりにする方法、
- 「列形式」は同じ種類の情報を並べる方法  
  となります。  
  その他にもデータを保存する方法はたくさんあるので、状況に応じて最適な方法を選ぶことが大切です。

---

### 1. 総処理時間の基本の考え方

データを使うとき、かかる時間は大きく 2 つに分けられます。

- **ディスクからデータを読む時間（I/O 時間）**
- **読み込んだデータを処理する時間（CPU 時間）**

これらを足し合わせたものが、全体のかかる時間です。これを数式で表すと、

\[
\text{総処理時間 (} T*{total} \text{)} = \text{I/O 時間 (} T*{I/O} \text{)} + \text{CPU 時間 (} T\_{CPU} \text{)}
\]

となります。

---

### 2. I/O 時間の計算式

ディスクからデータを読み込むときの時間は、「**読み込むデータの大きさ**」と「**ディスクの転送速度**」によって決まります。

式で表すと、

\[
T\_{I/O} = \frac{\text{読み込むデータサイズ}}{\text{ディスクの転送速度}}
\]

- **読み込むデータサイズ**  
  行形式の場合は、すべての列のデータを一度に読み込むので、たとえば「1 行あたり全ての情報 × 行数」になります。  
  列形式の場合は、必要な列だけを読み込むので、全体の一部のみとなります。

- **ディスクの転送速度**  
  これは、ディスクが 1 秒間にどれくらいのデータを読み込めるかを示しています。

**具体例:**  
もし、行形式の場合で 1 スクープ全体で 100MB、ディスクの転送速度が 50MB/秒なら、

\[
T\_{I/O} = \frac{100\,\text{MB}}{50\,\text{MB/秒}} = 2\,\text{秒}
\]

一方、列形式で必要な部分だけで 20MB なら、

\[
T\_{I/O} = \frac{20\,\text{MB}}{50\,\text{MB/秒}} = 0.4\,\text{秒}
\]

この違いが、行形式と列形式で処理時間に差が出る理由の一つです。

---

### 3. CPU 時間の計算式

CPU 時間は、読み込んだデータを使って計算する際の時間です。  
例えば、データを解凍したり、計算したりするのにかかる時間です。  
必要なデータが少ないほど、CPU で処理する量が減り、CPU 時間も短くなります。

- CPU 時間は一概に「データサイズに比例する」と考えることができますが、実際はデータの内容や処理方法に依存します。

---

### 4. 全体のまとめ

最終的に、

\[
T*{total} = \frac{\text{読み込むデータサイズ}}{\text{ディスクの転送速度}} + T*{CPU}
\]

という感じになります。

- **行形式**の場合、全データを読み込むので分子が大きくなり、時間が長くなります。
- **列形式**の場合、必要な部分だけを読み込むので分子が小さく、全体の時間が短縮されるという仕組みです。

---

このように、読み込むデータの量が少なくなると、ディスク読み込みにかかる時間 (I/O 時間) が減るため、全体の処理時間が短くなる、と理解できます。

### 行形式と列形式の違い

- **行形式データ**

  - 1 行に「太郎の名前」と「太郎の年齢」など、そのレコードに関するすべての情報がまとめられています。
  - 例：
    ```
    太郎, 15, 男, ...
    ```
    このように、各行がデータの「ひとまとまり」として扱われ、関連情報が物理的にも一緒に保存されます。

- **列形式データ**
  - 各列が同じ種類のデータをまとめて保存します。例えば、名前だけの列、年齢だけの列、性別だけの列という具合です。
  - 例：
    ```
    名前の列: [太郎, 花子, ...]
    年齢の列: [15, 16, ...]
    性別の列: [男, 女, ...]
    ```
  - **ただし、データ自体の関連は完全に失われるわけではありません**
    - 各列の順番がそろっているため、「名前の列」で 1 番目にある「太郎」と、「年齢の列」で 1 番目にある「15」は同じレコードに属します。
    - つまり、物理的には別々に保存されますが、読み出すときに同じインデックス（順番）で組み合わせることで、正しく「太郎の情報」として紐付けられます。

### まとめ

「太郎の名前」と「太郎の年齢」を関連付けるかどうかという点は、**行形式では物理的・直接的に一緒に保存されるのに対し、列形式では各列ごとに保存されるだけで、後で同じインデックスで組み合わせる仕組みになっている**という違いがあります。どちらの形式も論理的には正しい関連付けが可能ですが、列形式は特定の列のみの読み込みを効率化できる点が特徴です。
